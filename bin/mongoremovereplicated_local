#!/usr/bin/env node
// Generated by LiveScript 1.4.0
(function(){
  var async, mongoUri, levn, optionator, exec, ref$, MongoClient, ObjectId, option_parser, options, mongourl_src, mongourl_dst, listcollections, all_collections, getdb_src, getdb_dst, getcollection_src, getcollection_dst, remove_replicated_collection;
  async = require('async');
  mongoUri = require('mongo-uri');
  levn = require('levn');
  optionator = require('optionator');
  exec = require('shelljs').exec;
  ref$ = require('mongodb'), MongoClient = ref$.MongoClient, ObjectId = ref$.ObjectId;
  option_parser = optionator({
    options: [
      {
        option: 'src',
        alias: 's',
        type: 'String',
        description: 'source mongo url',
        'default': 'mongodb://localhost:27018/default'
      }, {
        option: 'dst',
        alias: 'd',
        type: 'String',
        description: 'destination mongo url',
        'default': 'mongodb://localhost:27017/default'
      }, {
        option: 'collections',
        alias: 'c',
        type: 'String',
        description: 'comma-separated list of collections to operate on'
      }, {
        option: 'help',
        alias: 'h',
        type: 'Boolean',
        description: 'display help'
      }
    ]
  });
  options = option_parser.parseArgv(process.argv);
  if (options.help != null) {
    console.log(option_parser.generateHelp());
    process.exit();
  }
  mongourl_src = options.src;
  mongourl_dst = options.dst;
  console.log('mongourl_src: ' + mongourl_src);
  console.log('mongourl_dst: ' + mongourl_dst);
  listcollections = function(uri){
    var login, host, db, user, passwd, mongocmd, mongocmdstr;
    login = mongoUri.parse(uri);
    if (login['hosts'][0] === 'localhost') {
      login['hosts'][0] = '127.0.0.1';
    }
    host = login['hosts'][0] + ':' + login['ports'][0];
    db = login['database'];
    user = login['username'];
    passwd = login['password'];
    mongocmd = ['mongo'];
    if (user != null) {
      mongocmd.push("--username " + user);
    }
    if (passwd != null) {
      mongocmd.push("--password " + passwd);
    }
    mongocmd.push((host + '/' + db) + " --eval 'db.getCollectionNames()'");
    mongocmdstr = mongocmd.join(' ');
    return levn.parse('[String]', exec(mongocmdstr).output.trim().split('\n').filter(function(x){
      return x.indexOf('MongoDB shell version') === -1 && x.indexOf('connecting to:') === -1;
    }).join('\n'));
  };
  if (options.collections != null) {
    all_collections = options.collections.split(',');
  } else {
    all_collections = listcollections(mongourl_dst);
  }
  console.log('collections:');
  console.log(all_collections);
  if (all_collections.length === 0) {
    console.log('no collections to dump');
    process.exit();
  }
  getdb_src = function(callback){
    return MongoClient.connect(mongourl_src, function(err, db){
      if (err) {
        return console.log('error getting mongodb');
      } else {
        return callback(db);
      }
    });
  };
  getdb_dst = function(callback){
    return MongoClient.connect(mongourl_dst, function(err, db){
      if (err) {
        return console.log('error getting mongodb');
      } else {
        return callback(db);
      }
    });
  };
  getcollection_src = function(collection_name, callback){
    return getdb_src(function(db){
      return callback(db.collection(collection_name), db);
    });
  };
  getcollection_dst = function(collection_name, callback){
    return getdb_dst(function(db){
      return callback(db.collection(collection_name), db);
    });
  };
  remove_replicated_collection = function(collection_name, callback){
    console.log(collection_name);
    return getcollection_src(collection_name, function(collection_src, db_src){
      return getcollection_dst(collection_name, function(collection_dst, db_dst){
        return collection_dst.find({}, {
          _id: 1
        }).toArray(function(err2, docs_dst){
          var dest_ids_list, res$, i$, len$, x;
          if (docs_dst != null) {
            res$ = [];
            for (i$ = 0, len$ = docs_dst.length; i$ < len$; ++i$) {
              x = docs_dst[i$];
              res$.push(x._id.toString());
            }
            dest_ids_list = res$;
          } else {
            dest_ids_list = [];
          }
          if (dest_ids_list.length === 0) {
            db_src.close();
            db_dst.close();
            return typeof callback == 'function' ? callback() : void 8;
          }
          return async.eachSeries(dest_ids_list, function(item, donecb){
            return collection_src.deleteOne({
              _id: ObjectId(item)
            }, {}, donecb);
          }, function(){
            db_src.close();
            db_dst.close();
            return typeof callback == 'function' ? callback() : void 8;
          });
        });
      });
    });
  };
  async.eachSeries(all_collections, function(collection_name, donecb){
    if (collection_name.startsWith('system.')) {
      return donecb();
    }
    return remove_replicated_collection(collection_name, donecb);
  });
}).call(this);
